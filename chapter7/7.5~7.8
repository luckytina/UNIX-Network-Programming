7.5通用套接字选项
7.5.1 SO_BROADCASE套接字选项
本选项开始或者禁止发送广播消息的能力。只有数据报套接字支持广播，并且是还是必须在支持广播消息
的网络上
7.5.2 SO_DEBUG套接字选项
本选项仅由tcp支持。当给tcp开启本选项时，内核将为tcp在该套接字接收和发送的所有分组保留详细跟踪信息
7.5.3 SO_DONTROUTE套接字选项
本选项规定外出分组将绕过底层协议的正常路由机制。举例来说，
7.5.4 SO_ERROR套接字选项
7.5.5 SO_KEEPALIVE套接字选项
给一个TCP套接字设置保持存活的选项后，如果2小时内在该套接字的任一方向上都没有数据交换，tcp就自动发给
对端发送一个保持存活探测分节。这是一个对端必须响应的TCP分节它会导致以下三种情况之一。
(1)对端以期望的ACK响应。应用进程得不到通知（因为一切正常）。在经过任然没有动静的2小时后，
tcp将发出另一个探测分节。
(2)对端以rst响应，它告知本端tcp:对端已崩溃且已重新启动。该套接字的待处理错误被设置为ECONNRESET，
套接字本身则被关闭。
(3)对端对保持存活探测分节没有任何响应。
如果根本没有对tcp的探测分节的响应，该套接字的待处理错误被设置为ETIMEOUT，套接字本身则被关闭
然而，如果该套接字收到一个icmp错误作为某个探测分节的响应，那么返回相应的错误，套接字本身也被关闭
本选项的功能是检测对端主机是否崩溃或者变为不可达。如果对端进程崩溃，它的tcp将跨连接发送一个FIN
这可以通过调用select很容易检测到。
本选项一般由服务器使用，不过客户端也可以使用。服务器使用本选项是因为他们花大部分时间阻在等待穿越
tcp连接的输入上，也就是说等待客户请求。保持存活选项将检测到这些半开连接并终止它。
7.5.6 SO_LINGER套接字选项
本选项指定close函数面向连接的协议如何操作。默认操作是close立即返回，但是如果有数据残留在套接字发送缓冲区
中，系统将试着把这些数据发送给对端。
分如下下列情形：本端tcp正主动发送数据，对端进程崩溃对端tcp发送一个FIN，通过使用select判断可读条件立即
能检测出来。如果本端tcp发送另外一个分节，对端tcp就以rst响应。如果在本端tcp收到rst之后应用进程任试着写套接字，
我们的套接字实现就给该进程发送一个SIGPIPE信号；对端进程崩溃，本端tcp将超时，且套接字的待处理错误被设置
为ETIMEOUT；如果对端主机不可达，本端tcp将超时，且套接字待处理错误被设置为EHOSTUNREACH;
本端tcp正主动接收数据，对端进程崩溃，对端将发送一个FIN，我们将把它作为一个EOF读入；对端主机崩溃时，我们将停止
接收数据；对端主机不可达时，我们将停止接收数据。
当连接空闲，保持存活选项已设置，对端进程崩溃对端tcp发送一个FIN，这通过使用select判断可读条件立即能检测出来；
对端主机崩溃，在毫无动静2小时后，发送9个保持存活探测分节，然后套接字待处理错误被设置为ETIMEOUT；在对端主机不可
达时，在毫无动静2小时后，发送9个保持存活探测分节，然后套接字的待处理错误被设置为EHOSTUNREACH
连接空闲，保持存活选项未设置；对端进程崩溃，对端发送一个FIN，这通过使用select判断可读条件立即能检测出来，对端
主机崩溃；对端主机不可达
SO_LINGER套接字选项使得我们可以改变这个默认设置。本选项要求在用户进程与内核间传递如下结构，它在头文件<sys/socket.h>
中定义：
struct linger{
		int l_onoff;
		int l_linger;
}
对setsockopt的调用将根据其中两个结构成员的值形成下列3种情况之一。
(1)如果l_onoff为0,那么关闭本选项。l_linger的值被忽略，先前讨论的tcp默认设置生效，即close立即返回。
(2)如果l_onoff为非0值且l_linger为0，那么当close某个连接时tcp将终止该连接。这就是说tcp将丢弃保留在套接字发送缓冲区
的任何数据，并发送rst给对端，而没有通常的四分组连接终止序列。
(3)如果l_onoff为非0值且l_linger也为非0值，那么当套接字关闭时内核将拖延一端时间。这就是说如果在套接字发送缓冲区残留
有数据，那么进程将被投入睡眠，那么进程将被投入睡眠，直到所有数据都已发送完且均被对方确认或延滞时间到。如果套接字
被设置为非阻塞型那么它将不等待close完成，即使延滞时间为非0也是如此。当使用SO_LINGER选项的这个特性时，应用进程检查
close的返回值是非常重要的，因为如果在数据发送完毕并被确认前延滞时间到的话，CLOSE将返回EWOULDBLOCK错误，且套接字发送
缓冲区的任何残留数据将被丢弃。
如图7-7close的默认操作是立即返回，我们假设在客户数据到达时，服务器暂时处于忙状态。那么这些数据由tcp加到服务器的
套接字缓冲区中。类似的，下一个分节即客户的FIN也加入到该套接字接收缓冲区。默认情况下客户的close立即返回。客户的close
可能在服务器套接字接收缓冲区剩余数据之前就返回。对于服务器主机来说，在服务器应用进程读这些数据之前就崩溃是完全可能的
而且客户应用进程永远不会知道。
客户可以设置SO_LINGER套接字选项，指定一个延滞时间。这种情况下客户的close要到它的数据和FIN已被服务器的TCP确认
后才返回。在服务器应用进程读剩余数据之前，服务器主机可能崩溃，并且客户应用进程永远不会知道
在SO_LINGER选项设置偏低时则会返回-1
在这里有一个基本原则：设置SO_LINGER套接字选项后，close的成功返回只是告诉我们先前发送的数据已由对端tcp确认，而
不能告诉我们对端应用进程是否已读取数据。如果不设置该选项我们连对端tcp是否确认了都不知道。
让客户端知道服务器已读取其数据的一个方法是改为调用shutdown而不是调用close，并等待对端close连接的当地端。
现汇总对shutdown的两种可能调用和对close的三种可能调用，以及它们对tcp套接字的影响。
shutdown SHUT_RD在套接字上不能再发出接收请求；进程任然可以往套接字发送数据；套接字接收缓冲区中所有数据被丢弃；再
接收到的任何数据由tcp丢弃；对套接字发送缓冲区没有任何影响
shutdown SHUT_WR在套接字上不能在发出发送请求；进程任然可以从套接字上接收数据；套接字发送缓冲区的内容被发送到对端
然后正常的tcp连接终止序列；对套接字接收缓冲区没有任何影响；
close l_onoff = 0 在套接字上不能发送或者接收请求；套接字发送缓冲区的内容被发送到对端。如果描述符引用计数变为0
在发送完发送缓冲区的数据后，跟已正常的tcp连接终止序列；套接字缓冲区的内容被丢弃
close l_onoff = 1 l_linger = 0 套接字不能再发出或连接请求。如果描述符引用计数变为0：rst被发送到对端；连接状态
被置为close套接字发送缓冲区和套接字接收缓冲区的数据被丢弃。
close l_onoff = 1 l_linger != 0在套接字上不能发出或接收请求；套接字发送缓冲区的数据被发送到对端，如果描述引用计数被
变为0：在发送完缓冲区中的数据后，跟着以tcp连接终止序列；套接字接收缓冲区中数据被丢弃；如果载连接变为CLOSE状态
前延滞时间到，那么close返回EWOULDBLOCK错误。



