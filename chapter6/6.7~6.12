6.7 str_cli函数（再修订版）
void str_cli(FILE *fp, int sockfd)
{
		int		maxfdp1, stdineof;
		fd_set	rset;
		char	buf[MAXLINE];
		int		n;

		stdineof = 0;
		FD_SIZE(&rset);
		for(;;)
		{
				if(stdineof == 0)
						FD_SET(fileno(fp), &rset);
				FD_SET(sockfd, &rset);
				maxfdp1 = max(fileno(fp), sockfd) + 1;
				select(maxfdp1, &rset, NULL, NULL, NULL);

				if(FD_ISSET(sockfd, &rset))
				{
						if((n = read(sockfd, buf,MAXLINE)) == 0)
						{
								if(stdineof ==1)
										return;
								else
										exit(1);
						}

						write(fileno(stdout), buf, n);
				}

				if(FD_ISSET(fileno(fp), &rset))
				{
					if((n = read(fileno(fp), buf, MAXLINE)) == 0)
					{
							stdineof = 1;
							shutdown(sockfd, SHUT_WR);
							FD_CLR(fileno(fp), &rset);
							continue;
					}
					write(sockfd, buf, n);
				}
		}
}

6.8 TCP回射服务器程序（修订版）
我们可以把TCP回射服务器重写成使用select来处理任意客户端的进程程序，而不是为每个客户
派生一个子进程。先让我们查看用以跟踪客户的数据结构。
代码如下所示：
int main(int argc, int **argv)
{
		int 		i, maxi, maxfd, listenfd, connfd, sockfd;
		int 		nready, client[FD_SETSIZE];
		ssize		n;
		fd_set		rset, allset;
		char		buf[MAXLINE];
		socklen_t	clien;
		struct sockaddr_in cliaddr, servaddr;

		listenfd = socket(AF_INET, SOCK_STREAM, 0);

		bzero(&servaddr, sizeof(servaddr));
		servaddr.sin_family = AF_INET;
		servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
		servaddr.sin_port = htons(SERV_PORT);

		bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr))
}
